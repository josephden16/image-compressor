{
  "version": 3,
  "sources": ["../src/index.ts", "../src/lib/utils.ts", "../src/lib/file.ts", "../src/lib/image.ts"],
  "sourcesContent": ["#!/usr/bin/env node\r\n\r\nimport chalk from \"chalk\";\r\nimport { getCommandlineInputs, setupYargsOptions } from \"lib/utils\";\r\nimport {\r\n  handleSingleImageFileCompression,\r\n  handleMultipleImageCompression,\r\n} from \"lib/image\";\r\n\r\nasync function main() {\r\n  try {\r\n    const { compressionLevel, imagesPath, outputPath } = getCommandlineInputs();\r\n    // Handle compression of a single image\r\n    const image = process.argv[2];\r\n    const shouldCompressSingleImage = image && !imagesPath;\r\n    if (shouldCompressSingleImage) {\r\n      await handleSingleImageFileCompression(image, compressionLevel);\r\n    } else {\r\n      // Handle compression of multiple images\r\n      await handleMultipleImageCompression(\r\n        imagesPath,\r\n        outputPath,\r\n        compressionLevel\r\n      );\r\n    }\r\n  } catch (error: any) {\r\n    console.error(chalk.red(error.message));\r\n  }\r\n}\r\n\r\nfunction runImageCompressor() {\r\n  setupYargsOptions();\r\n  main();\r\n}\r\n\r\nrunImageCompressor();\r\n", "import yargs from \"yargs\";\r\nimport { getRelativePath } from \"./file\";\r\n\r\nexport async function delay(ms: number) {\r\n  return new Promise((resolve) => {\r\n    setTimeout(resolve, ms);\r\n  });\r\n}\r\n\r\nexport function getCommandlineInputs() {\r\n  const { argv } = yargs(process.argv) as any;\r\n  let { imagesPath, outputPath, compressionLevel, i, o, c } = argv;\r\n  imagesPath = imagesPath || i;\r\n  outputPath = outputPath || o;\r\n  compressionLevel = compressionLevel || c;\r\n\r\n  if (compressionLevel) {\r\n    if (isNaN(parseInt(compressionLevel))) {\r\n      throw new Error(\"Error: Invalid compression level passed\");\r\n    }\r\n  }\r\n\r\n  return {\r\n    imagesPath,\r\n    outputPath,\r\n    compressionLevel,\r\n  };\r\n}\r\n\r\nexport function printSingleImageCompressionConclusion(outputFile: string) {\r\n  console.log(\r\n    `========================================\\n\\nOutput File: ${getRelativePath(\r\n      outputFile\r\n    )}\\n\\n========================================`\r\n  );\r\n}\r\n\r\nexport function printConclusion(imagesProcessed: number | string) {\r\n  console.log(\r\n    `========================================\\n\\nCompression complete!\\n\\nTotal Images Processed: ${imagesProcessed}\\n\\n========================================`\r\n  );\r\n}\r\n\r\nexport function printImageCompressionStatus(\r\n  image: string,\r\n  newFileSize: string,\r\n  originalFileSize: string\r\n) {\r\n  console.log(`Processing: ${image}\\n\\nOriginal Size: ${originalFileSize}MB   New Size: ${newFileSize}MB\r\n        `);\r\n}\r\n\r\nexport function printLineSection() {\r\n  console.log(`========================================`);\r\n}\r\n\r\nexport function printIntro(\r\n  imagesPath: string,\r\n  outputPath: string,\r\n  compressingSingleImage: boolean = false\r\n) {\r\n  console.log(`\\nCLI Image Compression Tool\\n\\n========================================\\n\\nImage${\r\n    compressingSingleImage ? \"\" : \"s\"\r\n  } Path: ${getRelativePath(imagesPath)}${\r\n    outputPath ? `\\nOutput Path: ${getRelativePath(outputPath)}` : \"\"\r\n  }\\n\\n========================================\r\n    `);\r\n}\r\n\r\nexport function setupYargsOptions() {\r\n  yargs\r\n    .usage(\r\n      \"pic-shrink is an easy-to-use CLI tool for compressing images in JPG, PNG, and WEBP.\\n\\nUsage: pic-shrink -i <images-path> -o <output-path> -c <compression-level>\"\r\n    )\r\n    .option(\"i\", {\r\n      alias: \"imagesPath\",\r\n      describe:\r\n        \"Path to the directory containing the images you want to compress.\",\r\n      type: \"string\",\r\n      demandOption: false,\r\n    })\r\n    .option(\"o\", {\r\n      alias: \"outputPath\",\r\n      describe:\r\n        \"Path to the directory where you want to store the compressed images\",\r\n      type: \"string\",\r\n      demandOption: false,\r\n    })\r\n    .option(\"c\", {\r\n      alias: \"compressionLevel\",\r\n      describe:\r\n        \"Optional value between 1 and 10 to specify the compression level for the images\",\r\n      type: \"number\",\r\n      demandOption: false,\r\n    })\r\n    .example([\r\n      [\"pic-shrink image.jpg\", \"Compress a single image file\"],\r\n      [\r\n        \"pic-shrink image.jpg -c 4\",\r\n        \"Compress a single image file with a custom compression level\",\r\n      ],\r\n      [\r\n        \"pic-shrink -i ./images\",\r\n        \"Compress images in the `images` directory and store the compressed images in the same directory\",\r\n      ],\r\n      [\r\n        \"pic-shrink -i ./images -o ./compressed\",\r\n        \"Compress images in the `images` directory and store them in the `compressed` folder\",\r\n      ],\r\n      [\r\n        \"pic-shrink -i ./images -c 8\",\r\n        \"Compress images in the `images` directory using a custom compression level of `8`\",\r\n      ],\r\n    ])\r\n    .parse();\r\n}\r\n", "import { statSync, lstatSync } from \"node:fs\";\r\nimport { parse, relative } from \"node:path\";\r\n\r\nexport function isFile(fileName: string) {\r\n  return lstatSync(fileName).isFile();\r\n}\r\n\r\nexport function getFileSize(filePath: string): string {\r\n  if (filePath) {\r\n    const stats = statSync(filePath);\r\n    const fileSizeInBytes = stats.size;\r\n    const fileSizeInMegabytes = fileSizeInBytes / (1024 * 1024);\r\n    return fileSizeInMegabytes.toFixed(2);\r\n  } else {\r\n    return \"0KB\";\r\n  }\r\n}\r\n\r\nexport function isImageFile(filePath: string) {\r\n  const fileExtension = parse(filePath).ext;\r\n  const imageFileExtensions = [\".jpg\", \".jpeg\", \".png\", \".webp\"];\r\n  return imageFileExtensions.includes(fileExtension);\r\n}\r\n\r\nexport function getRelativePath(absolutePath: string) {\r\n  const baseDir = process.cwd();\r\n  const relativePath = relative(baseDir, absolutePath);\r\n  return relativePath;\r\n}\r\n\r\nexport function getOutputFileName(imageFile: string) {\r\n  const { name, ext } = parse(imageFile);\r\n  const outputImagePath = `${name}_compressed${ext}`;\r\n  return outputImagePath;\r\n}\r\n", "import { join, parse, resolve } from \"path\";\r\nimport sharp, { Sharp, Metadata } from \"sharp\";\r\nimport { getFileSize, getOutputFileName, isFile, isImageFile } from \"./file\";\r\nimport {\r\n  delay,\r\n  printConclusion,\r\n  printImageCompressionStatus,\r\n  printIntro,\r\n  printLineSection,\r\n  printSingleImageCompressionConclusion,\r\n} from \"./utils\";\r\nimport { existsSync, mkdir, readdirSync } from \"fs\";\r\n\r\nexport async function compressImage(\r\n  imageFile: string,\r\n  compressionLevel: string,\r\n  outputImageDir: string\r\n) {\r\n  const image = sharp(imageFile) as Sharp;\r\n  const meta = (await image.metadata()) as Metadata;\r\n  const format = meta.format as \"jpeg\" | \"webp\" | \"png\";\r\n  const originalFileSize = getFileSize(imageFile);\r\n\r\n  const config = {\r\n    jpeg: { quality: 70 },\r\n    webp: { quality: 70 },\r\n    png: { compressionLevel: 7 },\r\n  };\r\n\r\n  let quality;\r\n  if (compressionLevel) {\r\n    // compression level for the images usually between 1 to 10\r\n    quality = parseInt(compressionLevel);\r\n    if (quality < 1) quality = 1;\r\n    if (quality > 10) quality = 10;\r\n    config.jpeg.quality = quality * 10;\r\n    config.webp.quality = quality * 10;\r\n    config.png.compressionLevel = quality;\r\n  }\r\n\r\n  const { dir, base } = parse(imageFile);\r\n  if (!outputImageDir) {\r\n    // Store the compressed images where the original images are located\r\n    const outputImageFilename = getOutputFileName(imageFile);\r\n    const outputImagePath = `${dir}/${outputImageFilename}`;\r\n    await image[format](config[format]).toFile(`${dir}/${outputImageFilename}`);\r\n    const newFileSize = getFileSize(outputImagePath);\r\n    printImageCompressionStatus(base, newFileSize, originalFileSize);\r\n  } else {\r\n    // Store the compressed images at the specified output directory\r\n    const outputImagePath = join(outputImageDir, base);\r\n    await image[format](config[format]).toFile(outputImagePath);\r\n    const newFileSize = getFileSize(outputImagePath);\r\n    printImageCompressionStatus(base, newFileSize, originalFileSize);\r\n  }\r\n}\r\n\r\nexport async function handleSingleImageFileCompression(\r\n  imagePath: string,\r\n  compressionLevel: string\r\n) {\r\n  const imageFilePath = resolve(imagePath);\r\n  const isImageValid = isImageFile(imageFilePath);\r\n  if (isImageValid) {\r\n    printIntro(imageFilePath, \"\", true);\r\n    await compressImage(imageFilePath, compressionLevel, \"\");\r\n    printSingleImageCompressionConclusion(getOutputFileName(imageFilePath));\r\n    return;\r\n  } else {\r\n    throw new Error(\"Error: Invalid image passed\");\r\n  }\r\n}\r\n\r\nexport async function handleMultipleImageCompression(\r\n  imagesPath: any,\r\n  outputPath: any,\r\n  compressionLevel: any\r\n) {\r\n  if (!imagesPath) {\r\n    throw new Error(\"Error: Images path not specified\");\r\n  }\r\n\r\n  const imageFilesPath = resolve(imagesPath);\r\n  if (!existsSync(imageFilesPath)) {\r\n    throw new Error(\"Error: Images file path is invalid\");\r\n  }\r\n\r\n  let outputImageDir: string;\r\n  if (outputPath) {\r\n    outputImageDir = resolve(outputPath);\r\n    if (outputImageDir && !existsSync(outputImageDir)) {\r\n      mkdir(outputImageDir, { recursive: true }, (error) => {\r\n        if (error) {\r\n          throw new Error(\r\n            `Error: Failed to create new directory at ${outputImageDir}`\r\n          );\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  printIntro(resolve(imagesPath), outputPath ? resolve(outputPath) : \"\");\r\n\r\n  // Read images in the directory\r\n  await delay(700);\r\n  console.log(\"Scanning directory for images...\");\r\n\r\n  const imageFiles = readdirSync(imageFilesPath)\r\n    .map((fileName) => join(imageFilesPath, fileName))\r\n    .filter(isFile)\r\n    .filter(isImageFile);\r\n\r\n  if (imageFiles.length === 0) {\r\n    throw new Error(`Error: No images found at: ${imageFilesPath}`);\r\n  }\r\n\r\n  await delay(1000);\r\n  console.log(`Found ${imageFiles.length} images.\\n`);\r\n\r\n  printLineSection();\r\n\r\n  await delay(1000);\r\n  console.log(\"\\nCompressing images...\\n\");\r\n\r\n  // Compress the images and store them in the appropriate location\r\n  await delay(1600);\r\n  let imagesProcessed = 0;\r\n  Promise.all(\r\n    imageFiles.map(async (imageFile) => {\r\n      await compressImage(imageFile, compressionLevel, outputImageDir);\r\n      imagesProcessed += 1;\r\n    })\r\n  ).then(async () => {\r\n    await delay(1000);\r\n    printConclusion(imagesProcessed);\r\n  });\r\n}\r\n"],
  "mappings": ";wdAEA,IAAAA,EAAkB,oBCFlB,IAAAC,EAAkB,oBCAlB,IAAAC,EAAoC,cACpCC,EAAgC,gBAEzB,SAASC,EAAOC,EAAkB,CACvC,SAAO,aAAUA,CAAQ,EAAE,OAAO,CACpC,CAEO,SAASC,EAAYC,EAA0B,CACpD,OAAIA,MACY,YAASA,CAAQ,EACD,MACiB,KAAO,OAC3B,QAAQ,CAAC,EAE7B,KAEX,CAEO,SAASC,EAAYD,EAAkB,CAC5C,IAAME,KAAgB,SAAMF,CAAQ,EAAE,IAEtC,MAD4B,CAAC,OAAQ,QAAS,OAAQ,OAAO,EAClC,SAASE,CAAa,CACnD,CAEO,SAASC,EAAgBC,EAAsB,CACpD,IAAMC,EAAU,QAAQ,IAAI,EAE5B,SADqB,YAASA,EAASD,CAAY,CAErD,CAEO,SAASE,EAAkBC,EAAmB,CACnD,GAAM,CAAE,KAAAC,EAAM,IAAAC,CAAI,KAAI,SAAMF,CAAS,EAErC,MADwB,GAAGC,CAAI,cAAcC,CAAG,EAElD,CD/BA,eAAsBC,EAAMC,EAAY,CACtC,OAAO,IAAI,QAASC,GAAY,CAC9B,WAAWA,EAASD,CAAE,CACxB,CAAC,CACH,CAEO,SAASE,GAAuB,CACrC,GAAM,CAAE,KAAAC,CAAK,KAAI,EAAAC,SAAM,QAAQ,IAAI,EAC/B,CAAE,WAAAC,EAAY,WAAAC,EAAY,iBAAAC,EAAkB,EAAAC,EAAG,EAAAC,EAAG,EAAAC,CAAE,EAAIP,EAK5D,GAJAE,EAAaA,GAAcG,EAC3BF,EAAaA,GAAcG,EAC3BF,EAAmBA,GAAoBG,EAEnCH,GACE,MAAM,SAASA,CAAgB,CAAC,EAClC,MAAM,IAAI,MAAM,yCAAyC,EAI7D,MAAO,CACL,WAAAF,EACA,WAAAC,EACA,iBAAAC,CACF,CACF,CAEO,SAASI,EAAsCC,EAAoB,CACxE,QAAQ,IACN;AAAA;AAAA,eAA4DC,EAC1DD,CACF,CAAC;AAAA;AAAA,yCACH,CACF,CAEO,SAASE,EAAgBC,EAAkC,CAChE,QAAQ,IACN;AAAA;AAAA;AAAA;AAAA,0BAAgGA,CAAe;AAAA;AAAA,yCACjH,CACF,CAEO,SAASC,EACdC,EACAC,EACAC,EACA,CACA,QAAQ,IAAI,eAAeF,CAAK;AAAA;AAAA,iBAAsBE,CAAgB,kBAAkBD,CAAW;AAAA,SAC5F,CACT,CAEO,SAASE,GAAmB,CACjC,QAAQ,IAAI,0CAA0C,CACxD,CAEO,SAASC,EACdhB,EACAC,EACAgB,EAAkC,GAClC,CACA,QAAQ,IAAI;AAAA;AAAA;AAAA;AAAA;AAAA,OACVA,EAAyB,GAAK,GAChC,UAAUT,EAAgBR,CAAU,CAAC,GACnCC,EAAa;AAAA,eAAkBO,EAAgBP,CAAU,CAAC,GAAK,EACjE;AAAA;AAAA;AAAA,KACG,CACL,CAEO,SAASiB,GAAoB,CAClC,EAAAnB,QACG,MACC;AAAA;AAAA,2EACF,EACC,OAAO,IAAK,CACX,MAAO,aACP,SACE,oEACF,KAAM,SACN,aAAc,EAChB,CAAC,EACA,OAAO,IAAK,CACX,MAAO,aACP,SACE,sEACF,KAAM,SACN,aAAc,EAChB,CAAC,EACA,OAAO,IAAK,CACX,MAAO,mBACP,SACE,kFACF,KAAM,SACN,aAAc,EAChB,CAAC,EACA,QAAQ,CACP,CAAC,uBAAwB,8BAA8B,EACvD,CACE,4BACA,8DACF,EACA,CACE,yBACA,iGACF,EACA,CACE,yCACA,qFACF,EACA,CACE,8BACA,mFACF,CACF,CAAC,EACA,MAAM,CACX,CEnHA,IAAAoB,EAAqC,gBACrCC,EAAuC,oBAUvC,IAAAC,EAA+C,cAE/C,eAAsBC,EACpBC,EACAC,EACAC,EACA,CACA,IAAMC,KAAQ,EAAAC,SAAMJ,CAAS,EAEvBK,GADQ,MAAMF,EAAM,SAAS,GACf,OACdG,EAAmBC,EAAYP,CAAS,EAExCQ,EAAS,CACb,KAAM,CAAE,QAAS,EAAG,EACpB,KAAM,CAAE,QAAS,EAAG,EACpB,IAAK,CAAE,iBAAkB,CAAE,CAC7B,EAEIC,EACAR,IAEFQ,EAAU,SAASR,CAAgB,EAC/BQ,EAAU,IAAGA,EAAU,GACvBA,EAAU,KAAIA,EAAU,IAC5BD,EAAO,KAAK,QAAUC,EAAU,GAChCD,EAAO,KAAK,QAAUC,EAAU,GAChCD,EAAO,IAAI,iBAAmBC,GAGhC,GAAM,CAAE,IAAAC,EAAK,KAAAC,CAAK,KAAI,SAAMX,CAAS,EACrC,GAAKE,EAOE,CAEL,IAAMU,KAAkB,QAAKV,EAAgBS,CAAI,EACjD,MAAMR,EAAME,CAAM,EAAEG,EAAOH,CAAM,CAAC,EAAE,OAAOO,CAAe,EAC1D,IAAMC,EAAcN,EAAYK,CAAe,EAC/CE,EAA4BH,EAAME,EAAaP,CAAgB,CACjE,KAbqB,CAEnB,IAAMS,EAAsBC,EAAkBhB,CAAS,EACjDY,EAAkB,GAAGF,CAAG,IAAIK,CAAmB,GACrD,MAAMZ,EAAME,CAAM,EAAEG,EAAOH,CAAM,CAAC,EAAE,OAAO,GAAGK,CAAG,IAAIK,CAAmB,EAAE,EAC1E,IAAMF,EAAcN,EAAYK,CAAe,EAC/CE,EAA4BH,EAAME,EAAaP,CAAgB,CACjE,CAOF,CAEA,eAAsBW,EACpBC,EACAjB,EACA,CACA,IAAMkB,KAAgB,WAAQD,CAAS,EAEvC,GADqBE,EAAYD,CAAa,EAC5B,CAChBE,EAAWF,EAAe,GAAI,EAAI,EAClC,MAAMpB,EAAcoB,EAAelB,EAAkB,EAAE,EACvDqB,EAAsCN,EAAkBG,CAAa,CAAC,EACtE,MACF,KACE,OAAM,IAAI,MAAM,6BAA6B,CAEjD,CAEA,eAAsBI,EACpBC,EACAC,EACAxB,EACA,CACA,GAAI,CAACuB,EACH,MAAM,IAAI,MAAM,kCAAkC,EAGpD,IAAME,KAAiB,WAAQF,CAAU,EACzC,GAAI,IAAC,cAAWE,CAAc,EAC5B,MAAM,IAAI,MAAM,oCAAoC,EAGtD,IAAIxB,EACAuB,IACFvB,KAAiB,WAAQuB,CAAU,EAC/BvB,GAAkB,IAAC,cAAWA,CAAc,MAC9C,SAAMA,EAAgB,CAAE,UAAW,EAAK,EAAIyB,GAAU,CACpD,GAAIA,EACF,MAAM,IAAI,MACR,4CAA4CzB,CAAc,EAC5D,CAEJ,CAAC,GAILmB,KAAW,WAAQG,CAAU,EAAGC,KAAa,WAAQA,CAAU,EAAI,EAAE,EAGrE,MAAMG,EAAM,GAAG,EACf,QAAQ,IAAI,kCAAkC,EAE9C,IAAMC,KAAa,eAAYH,CAAc,EAC1C,IAAKI,MAAa,QAAKJ,EAAgBI,CAAQ,CAAC,EAChD,OAAOC,CAAM,EACb,OAAOX,CAAW,EAErB,GAAIS,EAAW,SAAW,EACxB,MAAM,IAAI,MAAM,8BAA8BH,CAAc,EAAE,EAGhE,MAAME,EAAM,GAAI,EAChB,QAAQ,IAAI,SAASC,EAAW,MAAM;AAAA,CAAY,EAElDG,EAAiB,EAEjB,MAAMJ,EAAM,GAAI,EAChB,QAAQ,IAAI;AAAA;AAAA,CAA2B,EAGvC,MAAMA,EAAM,IAAI,EAChB,IAAIK,EAAkB,EACtB,QAAQ,IACNJ,EAAW,IAAI,MAAO7B,GAAc,CAClC,MAAMD,EAAcC,EAAWC,EAAkBC,CAAc,EAC/D+B,GAAmB,CACrB,CAAC,CACH,EAAE,KAAK,SAAY,CACjB,MAAML,EAAM,GAAI,EAChBM,EAAgBD,CAAe,CACjC,CAAC,CACH,CH/HA,eAAeE,GAAO,CACpB,GAAI,CACF,GAAM,CAAE,iBAAAC,EAAkB,WAAAC,EAAY,WAAAC,CAAW,EAAIC,EAAqB,EAEpEC,EAAQ,QAAQ,KAAK,CAAC,EACMA,GAAS,CAACH,EAE1C,MAAMI,EAAiCD,EAAOJ,CAAgB,EAG9D,MAAMM,EACJL,EACAC,EACAF,CACF,CAEJ,OAASO,EAAY,CACnB,QAAQ,MAAM,EAAAC,QAAM,IAAID,EAAM,OAAO,CAAC,CACxC,CACF,CAEA,SAASE,GAAqB,CAC5BC,EAAkB,EAClBX,EAAK,CACP,CAEAU,EAAmB",
  "names": ["import_chalk", "import_yargs", "import_node_fs", "import_node_path", "isFile", "fileName", "getFileSize", "filePath", "isImageFile", "fileExtension", "getRelativePath", "absolutePath", "baseDir", "getOutputFileName", "imageFile", "name", "ext", "delay", "ms", "resolve", "getCommandlineInputs", "argv", "yargs", "imagesPath", "outputPath", "compressionLevel", "i", "o", "c", "printSingleImageCompressionConclusion", "outputFile", "getRelativePath", "printConclusion", "imagesProcessed", "printImageCompressionStatus", "image", "newFileSize", "originalFileSize", "printLineSection", "printIntro", "compressingSingleImage", "setupYargsOptions", "import_path", "import_sharp", "import_fs", "compressImage", "imageFile", "compressionLevel", "outputImageDir", "image", "sharp", "format", "originalFileSize", "getFileSize", "config", "quality", "dir", "base", "outputImagePath", "newFileSize", "printImageCompressionStatus", "outputImageFilename", "getOutputFileName", "handleSingleImageFileCompression", "imagePath", "imageFilePath", "isImageFile", "printIntro", "printSingleImageCompressionConclusion", "handleMultipleImageCompression", "imagesPath", "outputPath", "imageFilesPath", "error", "delay", "imageFiles", "fileName", "isFile", "printLineSection", "imagesProcessed", "printConclusion", "main", "compressionLevel", "imagesPath", "outputPath", "getCommandlineInputs", "image", "handleSingleImageFileCompression", "handleMultipleImageCompression", "error", "chalk", "runImageCompressor", "setupYargsOptions"]
}
