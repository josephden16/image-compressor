{
  "version": 3,
  "sources": ["../src/index.ts", "../src/lib/utils.ts", "../src/lib/file.ts", "../src/lib/image.ts"],
  "sourcesContent": ["#!/usr/bin/env node\n\nimport chalk from \"chalk\";\nimport { getCommandlineInputs, setupYargsOptions } from \"lib/utils\";\nimport {\n  handleSingleImageFileCompression,\n  handleMultipleImageCompression,\n} from \"lib/image\";\nimport yargs from \"yargs\";\n\nasync function main() {\n  try {\n    if (process.argv.length < 3) {\n      yargs.showHelp();\n      return;\n    }\n    const { compressionLevel, imagesPath, outputPath } = getCommandlineInputs();\n    // Handle compression of a single image\n    const image = process.argv[2];\n    const shouldCompressSingleImage = image && !imagesPath;\n    if (shouldCompressSingleImage) {\n      await handleSingleImageFileCompression(image, compressionLevel);\n    } else if (imagesPath) {\n      // Handle compression of multiple images\n      await handleMultipleImageCompression(\n        imagesPath,\n        outputPath,\n        compressionLevel\n      );\n    }\n  } catch (error: any) {\n    console.error(chalk.red(error.message));\n  }\n}\n\nfunction runImageCompressor() {\n  setupYargsOptions();\n  main();\n}\n\nrunImageCompressor();\n", "import yargs from \"yargs\";\nimport { getRelativePath } from \"./file\";\n\nexport async function delay(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n\nexport function getCommandlineInputs() {\n  const { argv } = yargs(process.argv) as any;\n  let { imagesPath, outputPath, compressionLevel, i, o, c } = argv;\n  imagesPath = imagesPath || i;\n  outputPath = outputPath || o;\n  compressionLevel = compressionLevel || c;\n\n  if (compressionLevel) {\n    if (isNaN(parseInt(compressionLevel))) {\n      throw new Error(\"Error: Invalid compression level passed\");\n    }\n  }\n\n  return {\n    imagesPath,\n    outputPath,\n    compressionLevel,\n  };\n}\n\nexport function printSingleImageCompressionConclusion(outputFile: string) {\n  console.log(\n    `========================================\\n\\nOutput File: ${getRelativePath(\n      outputFile\n    )}\\n\\n========================================`\n  );\n}\n\nexport function printConclusion(imagesProcessed: number | string) {\n  console.log(\n    `========================================\\n\\nCompression complete!\\n\\nTotal Images Processed: ${imagesProcessed}\\n\\n========================================`\n  );\n}\n\nexport function printImageCompressionStatus(\n  image: string,\n  newFileSize: string,\n  originalFileSize: string\n) {\n  console.log(`Processing: ${image}\\n\\nOriginal Size: ${originalFileSize}MB   New Size: ${newFileSize}MB\n        `);\n}\n\nexport function printLineSection() {\n  console.log(`========================================`);\n}\n\nexport function printIntro(\n  imagesPath: string,\n  outputPath: string,\n  compressingSingleImage: boolean = false\n) {\n  console.log(`\\n========================================\\n\\nImage${\n    compressingSingleImage ? \"\" : \"s\"\n  } Path: ${getRelativePath(imagesPath)}${\n    outputPath ? `\\nOutput Path: ${getRelativePath(outputPath)}` : \"\"\n  }\\n\\n========================================\n    `);\n}\n\nexport function setupYargsOptions() {\n  yargs\n    .usage(\n      \"pic-shrink is an easy-to-use CLI tool for compressing images in JPG, PNG, and WEBP.\\n\\nUsage: pic-shrink <image-file-path>\"\n    )\n    .option(\"i\", {\n      alias: \"imagesPath\",\n      describe:\n        \"Path to the directory containing the images you want to compress.\",\n      type: \"string\",\n      demandOption: false,\n    })\n    .option(\"o\", {\n      alias: \"outputPath\",\n      describe:\n        \"Path to the directory where you want to store the compressed images\",\n      type: \"string\",\n      demandOption: false,\n    })\n    .option(\"c\", {\n      alias: \"compressionLevel\",\n      describe:\n        \"Optional value between 1 and 10 to specify the compression level for the images\",\n      type: \"number\",\n      demandOption: false,\n    })\n    .example([\n      [\"pic-shrink image.jpg\", \"Compress a single image file\"],\n      [\n        \"pic-shrink image.jpg -c 4\",\n        \"Compress a single image file with a custom compression level\",\n      ],\n      [\n        \"pic-shrink -i ./images\",\n        \"Compress images in the `images` directory and store the compressed images in the same directory\",\n      ],\n      [\n        \"pic-shrink -i ./images -o ./compressed\",\n        \"Compress images in the `images` directory and store them in the `compressed` folder\",\n      ],\n      [\n        \"pic-shrink -i ./images -c 8\",\n        \"Compress images in the `images` directory using a custom compression level of `8`\",\n      ],\n    ])\n    .parse();\n}\n", "import { statSync, lstatSync } from \"node:fs\";\nimport { parse, relative } from \"node:path\";\n\nexport function isFile(fileName: string) {\n  return lstatSync(fileName).isFile();\n}\n\nexport function getFileSize(filePath: string): string {\n  if (filePath) {\n    const stats = statSync(filePath);\n    const fileSizeInBytes = stats.size;\n    const fileSizeInMegabytes = fileSizeInBytes / (1024 * 1024);\n    return fileSizeInMegabytes.toFixed(2);\n  } else {\n    return \"0KB\";\n  }\n}\n\nexport function isImageFile(filePath: string) {\n  const fileExtension = parse(filePath).ext;\n  const imageFileExtensions = [\".jpg\", \".jpeg\", \".png\", \".webp\"];\n  return imageFileExtensions.includes(fileExtension);\n}\n\nexport function getRelativePath(absolutePath: string) {\n  const baseDir = process.cwd();\n  const relativePath = relative(baseDir, absolutePath);\n  return relativePath;\n}\n\nexport function getOutputFileName(imageFile: string) {\n  const { name, ext } = parse(imageFile);\n  const outputImagePath = `${name}_compressed${ext}`;\n  return outputImagePath;\n}\n", "import { join, parse, resolve } from \"path\";\nimport sharp, { Sharp, Metadata } from \"sharp\";\nimport { getFileSize, getOutputFileName, isFile, isImageFile } from \"./file\";\nimport {\n  delay,\n  printConclusion,\n  printImageCompressionStatus,\n  printIntro,\n  printLineSection,\n  printSingleImageCompressionConclusion,\n} from \"./utils\";\nimport { existsSync, mkdir, readdirSync } from \"fs\";\n\nexport async function compressImage(\n  imageFile: string,\n  compressionLevel: string,\n  outputImageDir: string\n) {\n  const image = sharp(imageFile) as Sharp;\n  const meta = (await image.metadata()) as Metadata;\n  const format = meta.format as \"jpeg\" | \"webp\" | \"png\";\n  const originalFileSize = getFileSize(imageFile);\n\n  const config = {\n    jpeg: { quality: 70 },\n    webp: { quality: 70 },\n    png: { compressionLevel: 7 },\n  };\n\n  let quality;\n  if (compressionLevel) {\n    // compression level for the images usually between 1 to 10\n    quality = parseInt(compressionLevel);\n    if (quality < 1) quality = 1;\n    if (quality > 10) quality = 10;\n    config.jpeg.quality = quality * 10;\n    config.webp.quality = quality * 10;\n    config.png.compressionLevel = quality;\n  }\n\n  const { dir, base } = parse(imageFile);\n  if (!outputImageDir) {\n    // Store the compressed images where the original images are located\n    const outputImageFilename = getOutputFileName(imageFile);\n    const outputImagePath = `${dir}/${outputImageFilename}`;\n    await image[format](config[format]).toFile(`${dir}/${outputImageFilename}`);\n    const newFileSize = getFileSize(outputImagePath);\n    printImageCompressionStatus(base, newFileSize, originalFileSize);\n  } else {\n    // Store the compressed images at the specified output directory\n    const outputImagePath = join(outputImageDir, base);\n    await image[format](config[format]).toFile(outputImagePath);\n    const newFileSize = getFileSize(outputImagePath);\n    printImageCompressionStatus(base, newFileSize, originalFileSize);\n  }\n}\n\nexport async function handleSingleImageFileCompression(\n  imagePath: string,\n  compressionLevel: string\n) {\n  const imageFilePath = resolve(imagePath);\n  const isImageValid = isImageFile(imageFilePath);\n  if (isImageValid) {\n    printIntro(imageFilePath, \"\", true);\n    await compressImage(imageFilePath, compressionLevel, \"\");\n    printSingleImageCompressionConclusion(getOutputFileName(imageFilePath));\n    return;\n  } else {\n    throw new Error(\"Error: Invalid image passed\");\n  }\n}\n\nexport async function handleMultipleImageCompression(\n  imagesPath: any,\n  outputPath: any,\n  compressionLevel: any\n) {\n  if (!imagesPath) {\n    throw new Error(\"Error: Images path not specified\");\n  }\n\n  const imageFilesPath = resolve(imagesPath);\n  if (!existsSync(imageFilesPath)) {\n    throw new Error(\"Error: Images file path is invalid\");\n  }\n\n  let outputImageDir: string;\n  if (outputPath) {\n    outputImageDir = resolve(outputPath);\n    if (outputImageDir && !existsSync(outputImageDir)) {\n      mkdir(outputImageDir, { recursive: true }, (error) => {\n        if (error) {\n          throw new Error(\n            `Error: Failed to create new directory at ${outputImageDir}`\n          );\n        }\n      });\n    }\n  }\n\n  printIntro(resolve(imagesPath), outputPath ? resolve(outputPath) : \"\");\n\n  // Read images in the directory\n  await delay(700);\n  console.log(\"Scanning directory for images...\");\n\n  const imageFiles = readdirSync(imageFilesPath)\n    .map((fileName) => join(imageFilesPath, fileName))\n    .filter(isFile)\n    .filter(isImageFile);\n\n  if (imageFiles.length === 0) {\n    throw new Error(`Error: No images found at: ${imageFilesPath}`);\n  }\n\n  await delay(1000);\n  console.log(`Found ${imageFiles.length} images.\\n`);\n\n  printLineSection();\n\n  await delay(1000);\n  console.log(\"\\nCompressing images...\\n\");\n\n  // Compress the images and store them in the appropriate location\n  await delay(1600);\n  let imagesProcessed = 0;\n  Promise.all(\n    imageFiles.map(async (imageFile) => {\n      await compressImage(imageFile, compressionLevel, outputImageDir);\n      imagesProcessed += 1;\n    })\n  ).then(async () => {\n    await delay(1000);\n    printConclusion(imagesProcessed);\n  });\n}\n"],
  "mappings": "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",
  "names": ["import_chalk", "import_yargs", "import_node_fs", "import_node_path", "isFile", "fileName", "getFileSize", "filePath", "isImageFile", "fileExtension", "getRelativePath", "absolutePath", "baseDir", "getOutputFileName", "imageFile", "name", "ext", "delay", "ms", "resolve", "getCommandlineInputs", "argv", "yargs", "imagesPath", "outputPath", "compressionLevel", "i", "o", "c", "printSingleImageCompressionConclusion", "outputFile", "getRelativePath", "printConclusion", "imagesProcessed", "printImageCompressionStatus", "image", "newFileSize", "originalFileSize", "printLineSection", "printIntro", "compressingSingleImage", "setupYargsOptions", "import_path", "import_sharp", "import_fs", "compressImage", "imageFile", "compressionLevel", "outputImageDir", "image", "sharp", "format", "originalFileSize", "getFileSize", "config", "quality", "dir", "base", "outputImagePath", "newFileSize", "printImageCompressionStatus", "outputImageFilename", "getOutputFileName", "handleSingleImageFileCompression", "imagePath", "imageFilePath", "isImageFile", "printIntro", "printSingleImageCompressionConclusion", "handleMultipleImageCompression", "imagesPath", "outputPath", "imageFilesPath", "error", "delay", "imageFiles", "fileName", "isFile", "printLineSection", "imagesProcessed", "printConclusion", "import_yargs", "main", "yargs", "compressionLevel", "imagesPath", "outputPath", "getCommandlineInputs", "image", "handleSingleImageFileCompression", "handleMultipleImageCompression", "error", "chalk", "runImageCompressor", "setupYargsOptions"]
}
